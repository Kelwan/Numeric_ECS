



1. Entity_Manager.cpp line 9
How do I access a an undeclared class in an other in another class? It is possible? I don't even know how you'd access the entities afterward.

2. System_Manager.h: line 36
I'm confused on how I access the stored 'value' instead of a vector 'type'

3. Entity reaching the 'process' system endpoint.
I seem to be having difficulties passing and entity around to finally reach process...

4. System_Manager in regards to templates
I'm not sure how to make a 'template' communicate between a .h and .cpp file. Less problems with inline.


entity_id ex: Networking, all running the same ECS system. The ID would be the same on all clients. Being able to see if the 'entities' are the same.

Future concept: Have a system creating entities. Ex: 'Goblin Spawner' system. Make a component for it too?

get_component_name

Ex:

example.h

public:
    template<typename T>
    void aFunction(T val);


example.cpp
    template<typename T>
    voidaFunction(T val)
    {
        return val * 2;
    }

5. I think there's something wrong the process on void. System_Manager.h: line 38

6. 

//I create two entities
//new rock
//new fish

//They're separate initializiations
//They're from the same class

//I don't understand how they're both showing a 'persistent' property ex: _entityId

//Entity_Manager: I wanted the counter to be 'persistent'
//A system is an overbearing presence that looks over your entities
//Having a counter there makes a lot of sense to make

I don't understand how these two completely initializiations of entity share a property they can both manipulate/use to communicate

// main.cpp

namespace {
    int thing;
}

void doThing() {
    cout << ++thing << std::endl;
}

class Thing {
    int value;
    Thing() {
        value = ++thing;
    }

    int thing;

    print() {
        cout << value << std::endl;
    }
}

int main() {


    thing = 0;

    auto* thing1 = new Thing(); <- different point in memory than thing2
    auto* thing2 = new Thing();

    thing1->print(); // 1
    thing2->print(); // 2

    return 0;
}


Entity entity; <- Use reference when calling as value 
Entity* entity2;

Gives access to memory address in declared scope. I could send a pointer and modify in scope with a reference.

process(&entity);
process(entity2);

